---
layout: home
title: Pain Points
sectionName: devexp
icon: fa-tint
order: 6
---

There were a lot of learnings from this project and, quite honestly, a fair bit of pain. I'm reconcilled to the pain though, as I'm fully aware that it's purely a consequence of my own decisions to use the tech stack I chose, and the versions thereof.

I couldn't document everything, but following is a list of some of the issues that either really hurt and took time to workaround, or are personal bugbears that I found frustrating:

* Getting a script together that would load the widget across all browsers was a trial. I actually proved that importing Webcomponents via a loader or via the full bundle resulted in different behaviour. The solution seems simple in hindsight but held me up significantly at the time.
* Unit testing Azure Serverless Functions is __hard__! MSBuild creates the project output in the folder specified in the project settings but puts everything, compiled binaries and dependencies, in an extra 'bin' folder under the folder specified. Test runners have a problem finding the classes in __referenced projects__. Hence I needed to incorporate the third party ContextResolver into the same project as the Function App. And even then, only the Visual Studio and Resharper test runners could process the result. My preferance is to use NCrunch but it doesn;t support Azure Serverless at this time.
* There seems to be a problem with the JavaScript mocking framework where TypeMoq appears to not be working as per the spec. I've tried rasing an issue on the project's Github, but activity from the owners of that project seems to be non-existent. To move forward one would likely need to choose a different mocking framework. For this project's current purposes however, the simple test case that works is enough to prove that the unit test infrastructre is workable. Out of interest, the TypeMoq issue is detailed on [Github](https://github.com/florinn/typemoq/issues/102).
* CORS was a real pain to solve. Early testing with Postman making calls to the back-end didn't reveal any connectivity issues. In fact, I'd never even come across the OPTIONS http header before and it took a significant amount of time to solve as CORS needed to be dealt with in not just the back-end code, but also in Azure's hosting environment which adds a futher level of protection.
* One of the last and most frustrating issues is the visual behaviour of the widget in non-Chrome browsers. Throughout the development process I tested across different browsers but only did so hosting the widget in a blank page. When hosting the widget in a real page with CSS defined (i.e. this website), non-Chrome browsers seem to be incorrectly inheriting styles from the page. This was discovered late by me and I've been unable to solve it quickly. The Polymer components chosen are specifically meant to NOT behave this way. If I had time, I would style all the UI elements myself, so I'm not overly concerned. It's just another of those things that chewed up a few hours trying to solve. The issue is detailed on [Github](https://github.com/PolymerElements/paper-dialog/issues/170).
* There's project available on Redux offering Polymer Redux bindings. I had figured to use this, but it doesn't properly support Polymer 3.x yet. There are several branches of the project purporting to have solved the problem but I couldn't find one that worked. I had to fall back to implementing a listener and state receiver and manually plumbing changes to local properties for the Polymer elements to bind to.
* Redux and TypeSript. A match made in heaven. If it's figured out. Until then, it's a match made hell. Enough said.
* It was also quite hard to rehydrate the applicable application state from local storage into the widget at reload and took some time to solve. It was hard due to a number of issues such as the way Polymer was binding to properties, the way Redux behaves when configuring the store with an intial state and most significantly, the order of async events. To solve it I needed to utilse the `PolymerElement`'s `ready()` event but I remain unconvinced that this is the best way to handle pushing the saved state back into Redix. I could have chosen to rerun all the Redux actions actions for the saved state but felt it was clunky but probably something I would have needed to do anyway if the 'Polymer Redux' binding had worked.